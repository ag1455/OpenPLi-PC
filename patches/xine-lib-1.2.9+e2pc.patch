diff -ruN o/configure.ac pc/configure.ac
--- o/configure.ac	2018-01-11 15:49:46.000000000 +0300
+++ pc/configure.ac	2023-09-16 16:10:03.755637080 +0300
@@ -1478,6 +1478,7 @@
 src/xine-utils/Makefile
 src/xine-engine/Makefile
 src/vdr/Makefile
+src/enigma/Makefile
 win32/Makefile])
 AC_CONFIG_COMMANDS([default],[[chmod +x ./misc/SlackBuild ./misc/build_rpms.sh ./misc/relchk.sh]],[[]])
 AC_OUTPUT
diff -ruN o/debian/changelog pc/debian/changelog
--- o/debian/changelog	2019-11-28 18:40:21.000000000 +0300
+++ pc/debian/changelog	2023-09-17 12:23:29.711190034 +0300
@@ -1,3 +1,9 @@
+xine-lib-1.2 (12:1.2.9-1build5-e2pc) focal; urgency=medium
+
+  * Rebuild with the new libdvdread soname
+
+ -- Sebastien Bacher <seb128@ubuntu.com>  Thu, 14 Sep 2023 19:05:34 +0100
+
 xine-lib-1.2 (1.2.9-1build5) focal; urgency=medium
 
   * Rebuild with the new libdvdread soname
diff -ruN o/debian/control pc/debian/control
--- o/debian/control	2019-08-08 18:36:18.000000000 +0300
+++ pc/debian/control	2023-09-16 16:10:03.756637027 +0300
@@ -202,6 +202,22 @@
  If you want to use vdr together with any xine front end, you need this
  package.
 
+Package: libxine2-enigma
+Architecture: any
+Multi-Arch: same
+Section: video
+Depends: libxine2-bin (= ${binary:Version}),
+ ${misc:Depends},
+ ${shlibs:Depends},
+Recommends:
+ enigma-plugin-xine,
+Description: VDR-related plugins for libxine2
+ This package contains plugins for the xine video/media player engine,
+ which require vdr to be of use.
+ .
+ If you want to use vdr together with any xine front end, you need this
+ package.
+
 Package: libxine2-x
 Architecture: any
 Multi-Arch: same
diff -ruN o/debian/libxine2-enigma.install pc/debian/libxine2-enigma.install
--- o/debian/libxine2-enigma.install	1970-01-01 03:00:00.000000000 +0300
+++ pc/debian/libxine2-enigma.install	2023-09-16 16:10:03.756637027 +0300
@@ -0,0 +1 @@
+debian/tmp/usr/lib/*/xine/plugins/*/xineplug_enigma.so
diff -ruN o/debian/rules pc/debian/rules
--- o/debian/rules	2018-03-25 23:06:11.000000000 +0300
+++ pc/debian/rules	2023-09-16 16:10:03.756637027 +0300
@@ -32,6 +32,7 @@
 	--disable-vidix \
 	--enable-directfb \
 	--disable-nosefart \
+	--enable-dvb \
 	$(DEB_BUILD_CONFIG_OPTIONS) \
 	$(shell dpkg-buildflags --export=configure) \
 	LIBMODPLUG_LIBS="$(filter-out -lstdc++ -lm,$(shell pkg-config --libs libmodplug))"
diff -ruN o/include/xine/metronom.h pc/include/xine/metronom.h
--- o/include/xine/metronom.h	2018-01-11 15:49:47.000000000 +0300
+++ pc/include/xine/metronom.h	2023-09-16 16:10:03.756637027 +0300
@@ -229,6 +229,9 @@
  *   metronom->set_option(metronom, METRONOM_LOCK, 0);
  */
 #define METRONOM_LOCK             9
+/* Nasty input_enigma helper. Inserts an immediate absolute discontinuity,
+ * old style without pts reorder fix. */
+#define METRONOM_ENIGMA_TRICK_PTS    10
 #define METRONOM_NO_LOCK          0x8000
 
 metronom_t *_x_metronom_init (int have_video, int have_audio, xine_t *xine) XINE_MALLOC XINE_PROTECTED;
diff -ruN o/include/xine/osd.h pc/include/xine/osd.h
--- o/include/xine/osd.h	2018-01-11 15:49:47.000000000 +0300
+++ pc/include/xine/osd.h	2023-09-16 16:10:03.757636976 +0300
@@ -216,6 +216,7 @@
    * overlay is blended at output (screen) resolution.
    */
   int (*show_unscaled) (osd_object_t *osd, int64_t vpts );
+  int (*show_scaled) (osd_object_t *osd, int64_t vpts );
 
   /*
    * see xine.h for defined XINE_OSD_CAP_ values.
diff -ruN o/include/xine/video_out.h pc/include/xine/video_out.h
--- o/include/xine/video_out.h	2018-01-11 15:49:47.000000000 +0300
+++ pc/include/xine/video_out.h	2023-09-16 16:10:03.757636976 +0300
@@ -274,6 +274,9 @@
 #define VO_PROP_MAX_VIDEO_WIDTH       28 /* read-only */
 #define VO_PROP_MAX_VIDEO_HEIGHT      29 /* read-only */
 #define VO_NUM_PROPERTIES             30
+#define VO_PROP_LAST_PTS              31
+#define VO_PROP_DEINTERLACE_SD        32
+#define VO_PROP_DEINTERLACE_HD        33
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
diff -ruN o/include/xine/xineintl.h pc/include/xine/xineintl.h
--- o/include/xine/xineintl.h	2018-01-11 15:49:47.000000000 +0300
+++ pc/include/xine/xineintl.h	2023-09-16 16:10:03.757636976 +0300
@@ -27,6 +27,9 @@
 
 #include <locale.h>
 
+//#define ENABLE_NLS
+//#define XINE_TEXTDOMAIN "libxine2"
+
 #ifdef ENABLE_NLS
 #    include <libintl.h>
 #    define _(String) dgettext (XINE_TEXTDOMAIN, String)
diff -ruN o/include/xine.h pc/include/xine.h
--- o/include/xine.h	2018-01-11 15:49:47.000000000 +0300
+++ pc/include/xine.h	2023-09-16 16:10:03.757636976 +0300
@@ -1778,6 +1778,7 @@
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
 #define XINE_EVENT_NBC_STATS             15 /* nbc buffer status */
+#define XINE_EVENT_FRAMERATE_CHANGE      16
 
 
 /* input events coming from frontend */
@@ -1869,6 +1870,17 @@
 /* events generated from post plugins */
 #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
 
+#define XINE_EVENT_SET_VIDEO_STREAMTYPE 501
+#define XINE_EVENT_SET_AUDIO_STREAMTYPE 502
+#define XINE_EVENT_SET_PVR_MODE         503
+
+/* some space for further keys */
+#define XINE_EVENT_ENIGMA_FRAMESIZECHANGED 504
+#define XINE_EVENT_ENIGMA_SELECTAUDIO      505
+#define XINE_EVENT_ENIGMA_TRICKSPEEDMODE   506
+#define XINE_EVENT_ENIGMA_PLUGINSTARTED    507
+#define XINE_EVENT_ENIGMA_DISCONTINUITY    508
+
 /*
  * xine event struct
  */
@@ -1902,6 +1914,11 @@
   char                str[256]; /* might be longer */
 } xine_ui_data_t;
 
+typedef struct {
+  int                 pid;
+  int                 streamtype;
+} xine_streamtype_data_t;
+
 /*
  * Send messages to UI. used mostly to report errors.
  */
@@ -1980,6 +1997,10 @@
   int                 type;         /* 0=buffer put, 1=buffer get */
 } xine_nbc_stats_data_t;
 
+typedef struct {
+  int64_t             framerate;
+} xine_framerate_data_t;
+
 /*
  * mrl reference data is sent by demuxers when a reference stream is found.
  * this stream just contains pointers (urls) to the real data, which are
@@ -2270,6 +2291,7 @@
 void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
 void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_scaled   (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 /* empty drawing area */
 void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
diff -ruN o/m4/input.m4 pc/m4/input.m4
--- o/m4/input.m4	2018-01-11 15:49:47.000000000 +0300
+++ pc/m4/input.m4	2023-09-16 16:10:03.758636923 +0300
@@ -18,6 +18,7 @@
     default_enable_vcd=yes
     default_enable_vcdo=no
     default_enable_vdr=yes
+    default_enable_enigma=yes
     default_enable_bluray=yes
     default_enable_avformat=yes
     default_with_external_dvdnav=yes
@@ -27,6 +28,7 @@
             default_enable_gnomevfs=no
             default_enable_samba=no
             default_enable_vdr=no
+            default_enable_enigma=no
             ;;
         darwin*)
             default_enable_gnomevfs=no
@@ -189,6 +191,10 @@
     XINE_ARG_ENABLE([vdr], [Enable support for the VDR plugin (default: enabled)])
     AM_CONDITIONAL([ENABLE_VDR], [test x"$enable_vdr" != x"no"])
 
+    dnl enigma
+    XINE_ARG_ENABLE([enigma], [Enable support for the ENIGMA plugin (default: enabled)])
+    AM_CONDITIONAL([ENABLE_ENIGMA], [test x"$enable_enigma" != x"no"])
+
     dnl bluray
     XINE_ARG_ENABLE([bluray], [Enable BluRay support])
     if test "x$enable_bluray" != "xno"; then
diff -ruN o/m4/summary.m4 pc/m4/summary.m4
--- o/m4/summary.m4	2018-01-11 15:49:47.000000000 +0300
+++ pc/m4/summary.m4	2023-09-16 16:10:03.758636923 +0300
@@ -25,6 +25,7 @@
         echo "   - dvd (*INTERNAL* libs)"
     fi
     test x"$enable_vdr" != x"no"    && echo "   - vdr"
+    test x"$enable_enigma" != x"no" && echo "   - enigma"
     test x"$have_dvb" = x"yes"      && echo "   - dvb"
     test x"$have_gnomevfs" = x"yes" && echo "   - gnome-vfs"
     test x"$have_samba" = x"yes"    && echo "   - smb"
@@ -149,6 +150,7 @@
     echo "   - unsharp         - tvtime"
     test x"$enable_postproc" != x"no" && echo "   - postproc"
     test x"$have_dvb" = x"yes"        && echo "   - vdr"
+    test x"$have_dvb" = x"yes"        && echo "   - enigma"
     echo "  * SFX:"
     echo "   - goom            - oscope"
     echo "   - fftscope        - mosaico"
diff -ruN o/src/demuxers/demux_ts.c pc/src/demuxers/demux_ts.c
--- o/src/demuxers/demux_ts.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/demuxers/demux_ts.c	2023-09-16 16:10:03.758636923 +0300
@@ -429,6 +429,7 @@
   off_t        tbre_bytes, tbre_lastpos;
   int64_t      tbre_time, tbre_lasttime;
   unsigned int tbre_mode, tbre_pid;
+  int          pvr_mode; // Default equal is '0', then pids receive from E2
 
 } demux_ts_t;
 
@@ -1823,6 +1824,7 @@
         break;
       }
       /* fall thru */
+      break;
 
     case HDMV_SPU_BITMAP:
       if (this->hdmv > 0) {
@@ -2300,6 +2302,9 @@
   }
 
   /* PAT */
+  // PAT and PMT are not processed for openpliPC. PIDs are recognized in E2
+ if (this->pvr_mode == 1)
+ {
   if (pid == 0) {
     demux_ts_parse_pat(this, originalPkt, originalPkt + data_offset,
 		       payload_unit_start_indicator, PKT_SIZE - data_offset);
@@ -2324,6 +2329,7 @@
     }
     program_count++;
   }
+ }
 
   data_len = PKT_SIZE - data_offset;
 
@@ -2385,6 +2391,7 @@
 static void demux_ts_event_handler (demux_ts_t *this) {
 
   xine_event_t *event;
+  int           mi;
 
   while ((event = xine_event_get (this->event_queue))) {
 
@@ -2395,6 +2402,7 @@
       /* flush all streams */
       demux_ts_flush(this);
       /* fall thru */
+      break;
 
     case XINE_EVENT_PIDS_CHANGE:
 
@@ -2403,6 +2411,36 @@
       _x_demux_control_start (this->stream);
       break;
 
+    case XINE_EVENT_SET_VIDEO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_VIDEO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_VIDEO_BASE, data->streamtype);
+        if (mi >= 0) {
+          this->videoPid = data->pid;
+          this->videoMedia = mi;
+        }
+      }
+      break;
+
+    case XINE_EVENT_SET_AUDIO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_AUDIO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_AUDIO_BASE, data->streamtype);
+      }
+      break;
+
+    case XINE_EVENT_SET_PVR_MODE:
+      printf("RECEIVED XINE_EVENT_SET_PVR_MODE\n");
+
+      this->pvr_mode = 1;
+      break;
+
     }
 
     xine_event_free (event);
@@ -2751,6 +2789,9 @@
   this->pkt_offset = (hdmv > 0) ? 4 : 0;
   this->pkt_size   = PKT_SIZE + this->pkt_offset;
 
+  /* PVR_MODE, default is LIVE_TV, pids receive from E2 */
+  this->pvr_mode = 0;
+
   return &this->demux_plugin;
 }
 
diff -ruN o/src/enigma/combined_enigma.c pc/src/enigma/combined_enigma.c
--- o/src/enigma/combined_enigma.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/combined_enigma.c	2023-09-16 16:10:03.759636871 +0300
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2000-2018 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * plugins for VDR
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+static const post_info_t enigma_video_special_info = { XINE_POST_TYPE_VIDEO_FILTER };
+static const post_info_t enigma_audio_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
+
+/* exported plugin catalog entry */
+const plugin_info_t xine_plugin_info[] EXPORTED =
+{
+  /* type       , API, "name"     , version          , special_info                 , init_function */
+  { PLUGIN_INPUT,  18, "ENIGMA"      , XINE_VERSION_CODE, NULL                      , &enigma_input_init_plugin },
+  { PLUGIN_POST ,  10, "enigma"      , XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_video", XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_audio", XINE_VERSION_CODE, &enigma_audio_special_info, &enigma_audio_init_plugin },
+  { PLUGIN_NONE ,   0, NULL          , 0                , NULL                      , NULL }
+};
+
diff -ruN o/src/enigma/combined_enigma.h pc/src/enigma/combined_enigma.h
--- o/src/enigma/combined_enigma.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/combined_enigma.h	2023-09-16 16:10:03.759636871 +0300
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2000-2018 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifndef __COMBINED_ENIGMA_H
+#define __COMBINED_ENIGMA_H
+
+typedef struct enigma_set_video_window_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+} enigma_set_video_window_data_t;
+
+typedef struct enigma_frame_size_changed_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  double r;
+
+} enigma_frame_size_changed_data_t;
+
+typedef struct enigma_select_audio_data_s {
+  uint8_t channels;
+
+} enigma_select_audio_data_t;
+
+inline static int enigma_is_stream(xine_stream_t *stream)
+{
+  if (!stream
+      || !stream->input_plugin
+      || !stream->input_plugin->input_class)
+  {
+    return 0;
+  }
+
+  if (stream->input_plugin->input_class->identifier &&
+      0 == strcmp(stream->input_plugin->input_class->identifier, "ENIGMA"))
+    return 1;
+
+  return 0;
+}
+
+/* plugin class initialization function */
+void *enigma_input_init_plugin(xine_t *xine, const void *data);
+void *enigma_video_init_plugin(xine_t *xine, const void *data);
+void *enigma_audio_init_plugin(xine_t *xine, const void *data);
+
+#endif /* __COMBINED_ENIGMA_H */
diff -ruN o/src/enigma/input_enigma.c pc/src/enigma/input_enigma.c
--- o/src/enigma/input_enigma.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/input_enigma.c	2023-09-16 16:10:03.759636871 +0300
@@ -0,0 +1,854 @@
+/*
+ * Copyright (C) 2003-2019 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/* NOTE: This will bend the xine engine into a certain direction (just to avoid the
+ * term "misuse"). Demux keeps running all the time. Its the enigma server that
+ * performs seeks, stream switches, still frames, trick play frames etc.
+ * It then muxes the result down the line sequentially. For the demuxer, most stuff
+ * looks like ordinary absolute discontinuities. We need to watch the control
+ * messages coming through a side channel, and inject apropriate xine engine calls
+ * manually. In reverse, we listen to xine events, and send back enigma keys.
+ * "Trick play" is turned on and off by server. When on, xine shall just play all
+ * frames as if they had perfectly consecutive time stamps. We still need to register
+ * first discontinuity early because server will wait for it, and video decoder may
+ * delay it -> freeze.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <pthread.h>
+
+#define LOG_MODULE "input_enigma"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+#include <xine/input_plugin.h>
+#include <xine/input_plugin.h>
+
+#include "combined_enigma.h"
+#include "net_buf_ctrl.h" /* ? */
+
+// xvdr
+#include <sys/time.h>
+
+#define ENIGMA_ABS_FIFO_DIR     "/tmp"
+#define DEFAULT_PTS_START       150000
+#define BUFSIZE                 1024
+#define FILE_FLAGS O_RDONLY
+#define FIFO_PUT                0
+// xvdr
+#define XVDR_METRONOM_OPTION_BASE  0x1001
+#define XVDR_METRONOM_LAST_VO_PTS  (XVDR_METRONOM_OPTION_BASE)
+#define XVDR_METRONOM_TRICK_SPEED  (XVDR_METRONOM_OPTION_BASE + 1)
+#define XVDR_METRONOM_STILL_MODE   (XVDR_METRONOM_OPTION_BASE + 2)
+#define XVDR_METRONOM_ID           (XVDR_METRONOM_OPTION_BASE + 3)
+
+#define XVDR_METRONOM_LIVE_BUFFERING   (XVDR_METRONOM_OPTION_BASE + 4)
+#define XVDR_METRONOM_STREAM_START     (XVDR_METRONOM_OPTION_BASE + 5)
+
+typedef struct enigma_input_plugin_s enigma_input_plugin_t;
+
+  /* This is our relay metronom, built on top of the engine one.
+   * src/xine-engine/metronom.c uses a much more complex algorithm now.
+   * One goal is to avoid unnecessary waiting. Thus lets not wait
+   * ourselves here, and detect complete discontinuity pairs instead. */
+typedef struct {
+  metronom_t          metronom;
+  metronom_t         *stream_metronom;
+  enigma_input_plugin_t *input;
+  // xvdr
+  int     trickspeed;    /* current trick speed */
+  int     still_mode;
+  int64_t last_vo_pts;   /* last displayed video frame PTS */
+  int     wired;         /* true if currently wired to stream */
+
+  /* initial buffering in live mode */
+  uint8_t  buffering;      /* buffering active */
+  uint8_t  live_buffering; /* live buffering enabled */
+  uint8_t  stream_start;
+  int64_t  vid_pts;        /* last seen video pts */
+  int64_t  aud_pts;        /* last seen audio pts */
+  int64_t  disc_pts;       /* reported discontinuity pts */
+  uint64_t buffering_start_time;
+  uint64_t first_frame_seen_time;
+
+  pthread_mutex_t mutex;
+}
+enigma_metronom_t;
+
+typedef struct enigma_osd_s
+{
+  xine_osd_t *window;
+  uint8_t    *argb_buffer[ 2 ];
+  int         width;
+  int         height;
+}
+enigma_osd_t;
+
+typedef struct enigma_vpts_offset_s enigma_vpts_offset_t;
+
+struct enigma_vpts_offset_s
+{
+  enigma_vpts_offset_t *next;
+  int64_t            vpts;
+  int64_t            offset;
+};
+
+struct enigma_input_plugin_s {
+  input_plugin_t      input_plugin;
+  xine_stream_t      *stream;
+  int                 fh;
+  char               *mrl;
+  off_t               curpos;
+  char                seek_buf[BUFSIZE];
+  xine_t             *xine;
+  int                 last_disc_type;
+
+  uint8_t             trick_speed_mode;
+  uint8_t             trick_speed_mode_blocked;
+  pthread_mutex_t     trick_speed_mode_lock;
+  pthread_cond_t      trick_speed_mode_cond;
+
+  pthread_t           metronom_thread;
+  pthread_mutex_t     metronom_thread_lock;
+  int64_t             metronom_thread_request;
+  int                 metronom_thread_reply;
+  pthread_cond_t      metronom_thread_request_cond;
+  pthread_cond_t      metronom_thread_reply_cond;
+  pthread_mutex_t     metronom_thread_call_lock;
+
+  uint8_t             find_sync_point;
+  pthread_mutex_t     find_sync_point_lock;
+
+  enigma_metronom_t      metronom;
+
+  enigma_vpts_offset_t  *vpts_offset_queue;
+  enigma_vpts_offset_t  *vpts_offset_queue_tail;
+  pthread_mutex_t     vpts_offset_queue_lock;
+  pthread_cond_t      vpts_offset_queue_changed_cond;
+  int                 vpts_offset_queue_changes;
+
+  // xvdr
+  int     trickspeed;    // current trick speed
+  int     still_mode;
+  int64_t last_vo_pts;   // last displayed video frame PTS
+  int     wired;         // true if currently wired to stream
+};
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+} enigma_input_class_t;
+
+// xvdr
+static uint64_t time_ms(void)
+{
+  struct timeval t;
+#ifdef XINEUTILS_H
+  if (xine_monotonic_clock(&t, NULL) == 0)
+#else
+  if (gettimeofday(&t, NULL) == 0)
+#endif
+     return ((uint64_t)t.tv_sec) * 1000ULL + t.tv_usec / 1000ULL;
+  return 0;
+}
+
+static uint64_t elapsed(uint64_t t)
+{
+  return time_ms() - t;
+}
+
+static int warnings = 0;
+
+static int64_t absdiff(int64_t a, int64_t b) { int64_t diff = a-b; if (diff<0) diff = -diff; return diff; }
+static int64_t min64(int64_t a, int64_t b) { return a < b ? a : b; }
+
+static void check_buffering_done(enigma_metronom_t *this)
+{
+  /* both audio and video timestamps seen ? */
+  if (this->vid_pts && this->aud_pts) {
+    int64_t da = this->aud_pts - this->disc_pts;
+    int64_t dv = this->vid_pts - this->disc_pts;
+    int64_t d_min = min64(da, dv);
+    printf("  stream A-V diff %d ms", (int)(this->vid_pts - this->aud_pts)/90);
+    printf("  reported stream start at pts %"PRId64, this->disc_pts);
+    printf("  output fifo end at: audio %"PRId64" video %"PRId64, this->aud_pts, this->vid_pts);
+    printf("  dA %"PRId64" dV %"PRId64, da, dv);
+    if (d_min < 0 && d_min > -10*90000) {
+      printf("  *** output is late %"PRId64" ticks (%"PRId64" ms) ***", d_min, -d_min/90);
+    }
+    this->buffering = 0;
+    this->stream_start = 0;
+    return;
+  }
+
+  if (this->first_frame_seen_time) {
+    int64_t ms_since_first_frame = elapsed(this->first_frame_seen_time);
+
+    if (ms_since_first_frame > 1000) {
+
+      this->stream_start = 0;
+
+      /* abort buffering if no audio */
+      if (this->vid_pts && !this->aud_pts) {
+        printf("buffering stopped: NO AUDIO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+        return;
+      }
+
+      /* abort buffering if no video */
+      if (!this->vid_pts && this->aud_pts) {
+        printf("buffering stopped: NO VIDEO ? elapsed time %d ms", (int)ms_since_first_frame);
+        this->buffering = 0;
+        return;
+      }
+    }
+  }
+}
+
+static void got_video_frame(metronom_t *self, vo_frame_t *frame)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  int64_t          pts  = frame->pts;
+
+  if (this->still_mode) {
+    printf("Still frame, type %d", frame->picture_coding_type);
+    frame->pts       = 0;
+  }
+
+  if (this->trickspeed) {
+    frame->pts       = 0;
+    frame->duration *= 12; /* GOP */
+  }
+
+  /* initial buffering */
+  pthread_mutex_lock(&this->mutex);
+  if (this->buffering && !frame->bad_frame) {
+
+    /* track video pts */
+    if (pts) {
+      if (this->vid_pts && (absdiff(this->vid_pts, pts) > 5*90000)) {
+        printf("buffering: video jump resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (this->vid_pts && this->aud_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted audio pts");
+        this->aud_pts = 0;
+      }
+      if (!this->vid_pts) {
+        printf("got video pts, frame type %d (@%d ms)", frame->picture_coding_type, (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms(); 
+      }
+      this->vid_pts = pts;
+    }
+
+    /* some logging */
+    if (!pts) {
+      printf("got video, pts 0, buffering, frame type %d, bad_frame %d", frame->picture_coding_type, frame->bad_frame);
+    }
+    if (pts && !frame->pts) {
+      printf("*** ERROR: hiding video pts while buffering ***");
+    }
+
+    check_buffering_done(this);
+  }
+
+  pthread_mutex_unlock(&this->mutex);
+
+  this->stream_metronom->got_video_frame (this->stream_metronom, frame);
+
+  frame->pts = pts;
+}
+
+static int64_t got_audio_samples(metronom_t *self, int64_t pts, int nsamples)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  pthread_mutex_lock(&this->mutex);
+
+  /* initial buffering */
+  if (this->buffering) {
+
+    /* track audio pts */
+    if (pts) {
+      if (this->aud_pts && (this->aud_pts > pts || absdiff(pts, this->aud_pts) > 5*90000)) {
+        printf("audio jump resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (this->aud_pts && this->vid_pts && (absdiff(this->vid_pts, this->aud_pts) > 5*90000)) {
+        printf("buffering: A-V diff resetted video pts");
+        this->vid_pts = 0;
+      }
+      if (!this->aud_pts) {
+        printf("got audio pts (@%d ms)", (int)elapsed(this->buffering_start_time));
+        this->first_frame_seen_time = time_ms();
+      }
+      this->aud_pts = pts;
+    }
+
+    /* some logging */
+    if (!pts && !this->aud_pts) {
+      printf("got audio, pts 0, buffering");
+    }
+
+    check_buffering_done(this);
+  }
+
+  pthread_mutex_unlock(&this->mutex);
+
+  return this->stream_metronom->got_audio_samples (this->stream_metronom, pts, nsamples);
+}
+
+static int64_t got_spu_packet(metronom_t *self, int64_t pts)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  return this->stream_metronom->got_spu_packet(this->stream_metronom, pts);
+}
+
+static void start_buffering(enigma_metronom_t *this, int64_t disc_off)
+{
+  if (this->live_buffering && this->stream_start && disc_off) {
+    if (!this->buffering) {
+      printf("live mode buffering started (@%d ms)", (int)elapsed(this->buffering_start_time));
+
+      this->aud_pts  = 0;
+      this->vid_pts  = 0;
+      this->disc_pts = disc_off;
+
+      this->first_frame_seen_time = 0;
+
+      this->buffering = 1;
+    }
+  } else {
+    if (this->buffering) {
+      printf("live mode buffering aborted (@%d ms)", (int)elapsed(this->buffering_start_time));
+      this->buffering = 0;
+    }
+  }
+}
+
+static void handle_audio_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_audio_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void handle_video_discontinuity(metronom_t *self, int type, int64_t disc_off)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  start_buffering(this, disc_off);
+
+  this->stream_metronom->handle_video_discontinuity(this->stream_metronom, type, disc_off);
+}
+
+static void set_audio_rate(metronom_t *self, int64_t pts_per_smpls)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_audio_rate(this->stream_metronom, pts_per_smpls);
+}
+
+static void set_option(metronom_t *self, int option, int64_t value)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    if (value > 0) {
+      pthread_mutex_lock(&this->mutex);
+      this->last_vo_pts = value;
+      pthread_mutex_unlock(&this->mutex);
+    }
+    return;
+  }
+
+  if (option == XVDR_METRONOM_LIVE_BUFFERING) {
+    pthread_mutex_lock(&this->mutex);
+    this->live_buffering = value;
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STREAM_START) {
+    pthread_mutex_lock(&this->mutex);
+    this->stream_start = 1;
+    this->buffering_start_time = time_ms();
+    pthread_mutex_unlock(&this->mutex);
+    return;
+  }
+
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    this->trickspeed = value;
+    return;
+  }
+
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    this->still_mode = value;
+    return;
+  }
+
+  this->stream_metronom->set_option(this->stream_metronom, option, value);
+}
+
+static int64_t get_option(metronom_t *self, int option)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  if (option == XVDR_METRONOM_LAST_VO_PTS) {
+    int64_t pts;
+    pthread_mutex_lock(&this->mutex);
+    pts = this->last_vo_pts;
+    pthread_mutex_unlock(&this->mutex);
+    return pts;
+  }
+  if (option == XVDR_METRONOM_TRICK_SPEED) {
+    return this->trickspeed;
+  }
+  if (option == XVDR_METRONOM_STILL_MODE) {
+    return this->still_mode;
+  }
+  if (option == XVDR_METRONOM_ID) {
+    return XVDR_METRONOM_ID;
+  }
+
+  return this->stream_metronom->get_option(this->stream_metronom, option);
+}
+
+static void set_master(metronom_t *self, metronom_t *master)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+  this->stream_metronom->set_master(this->stream_metronom, master);
+}
+
+static void metronom_exit(metronom_t *self)
+{
+  enigma_metronom_t *this = (enigma_metronom_t *)self;
+
+  _x_abort();
+}
+
+static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{
+  off_t ret;
+
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+
+    break;
+  }
+
+  return ret;
+}
+
+static off_t enigma_plugin_read (input_plugin_t *this_gen,
+				void *buf_gen, off_t len) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+  uint8_t *buf = (uint8_t *)buf_gen;
+  off_t n, total = 0;
+#ifdef LOG_READ
+  lprintf ("reading %lld bytes...\n", len);
+#endif
+
+  if( len > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = enigma_read_abort (this->stream, this->fh, (char *)&buf[total], len-total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); // 200 * 50ms
+#ifdef LOG_READ
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n", n, total, len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+
+  if (this->find_sync_point
+    && total == 6)
+  {
+    pthread_mutex_lock(&this->find_sync_point_lock);
+
+    while (this->find_sync_point
+      && total == 6
+      && buf[0] == 0x00
+      && buf[1] == 0x00
+      && buf[2] == 0x01)
+    {
+      int l, sp;
+
+      if (buf[3] == 0xbe
+        && buf[4] == 0xff)
+      {
+        if (buf[5] == this->find_sync_point)
+        {
+          this->find_sync_point = 0;
+          break;
+        }
+      }
+
+      if ((buf[3] & 0xf0) != 0xe0
+        && (buf[3] & 0xe0) != 0xc0
+        && buf[3] != 0xbd
+        && buf[3] != 0xbe)
+      {
+        break;
+      }
+
+      l = buf[4] * 256 + buf[5];
+      if (l <= 0)
+         break;
+
+      sp = this->find_sync_point;
+      this->find_sync_point = 0;
+      this_gen->seek(this_gen, l, SEEK_CUR);
+      total = this_gen->read(this_gen, buf, 6);
+      this->find_sync_point = sp;
+    }
+
+    pthread_mutex_unlock(&this->find_sync_point_lock);
+  }
+
+  return total;
+
+}
+
+static buf_element_t *enigma_plugin_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo,
+					off_t todo) {
+
+  off_t                 total_bytes;
+  buf_element_t         *buf = fifo->buffer_pool_alloc (fifo);
+
+  if (todo > buf->max_size)
+    todo = buf->max_size;
+  if (todo < 0) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = enigma_plugin_read (this_gen, (char*)buf->content, todo);
+
+  if (total_bytes != todo) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t enigma_plugin_get_current_pos(input_plugin_t *this_gen);
+
+static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("seek %"PRId64" offset, %d origin...\n", offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0)) {
+
+    for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+      if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET) {
+
+    if (offset < this->curpos) {
+        xprintf (this->xine, XINE_VERBOSITY_LOG,
+                 _("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n"),
+                 (intmax_t)this->curpos, (intmax_t)offset);
+        printf ("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n",
+                 (intmax_t)this->curpos, (intmax_t)offset);
+
+    } else {
+      offset -= this->curpos;
+
+      for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+        if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+          return this->curpos;
+      }
+
+      this_gen->read (this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t enigma_plugin_get_length(input_plugin_t *this_gen) {
+  return 0;
+}
+
+static uint32_t enigma_plugin_get_capabilities(input_plugin_t *this_gen) {
+
+  return INPUT_CAP_PREVIEW;
+}
+
+static uint32_t enigma_plugin_get_blocksize(input_plugin_t *this_gen) {
+
+  return 0;
+}
+
+static off_t enigma_plugin_get_current_pos (input_plugin_t *this_gen){
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->curpos;
+}
+
+static const char* enigma_plugin_get_mrl (input_plugin_t *this_gen) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->mrl;
+}
+
+static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  pthread_mutex_destroy(&this->metronom.mutex);
+
+  pthread_mutex_destroy(&this->find_sync_point_lock); // need
+
+
+  if (this->fh != -1)
+    close(this->fh);
+
+  free (this->mrl);
+
+  this->stream->metronom = this->metronom.stream_metronom;
+  this->metronom.stream_metronom = 0;
+
+  free (this);
+}
+
+static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
+					void *data, int data_type) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+  (void)this; //Add from 
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    /* just fake what mpeg_pes demuxer expects */
+    memcpy (data, "\x00\x00\x01\xe0\x00\x03\x80\x00\x00", 9);
+    return 9;
+  case INPUT_OPTIONAL_DATA_DEMUXER:
+    {
+      char **tmp = (char**)data;
+      *tmp = "mpeg-ts";
+    }
+    return 0;
+  }
+
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int enigma_plugin_open (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1) {
+    char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
+    this->fh = open (filename, FILE_FLAGS);
+
+    printf("filename '%s'\n", filename);
+
+    if (this->fh == -1) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, _("enigma_fifo: failed to open '%s'\n"), filename);
+      printf ("enigma_fifo: failed to open '%s'\n", filename);
+      return 0;
+    }
+
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this->curpos          = 0;
+
+  return 1;
+}
+
+static input_plugin_t *enigma_class_get_instance (input_class_t *class_gen,
+						xine_stream_t *stream, const char *data) {
+
+  enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
+  enigma_input_plugin_t *this;
+  char                 *mrl = strdup(data);
+
+  if (!strncasecmp(mrl, "enigma:/", 8)) {
+    lprintf("Enigma plugin\n");
+  } else {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this       = calloc(1, sizeof(enigma_input_plugin_t));
+
+  this->stream = stream;
+  this->curpos = 0;
+  this->mrl    = mrl;
+  this->fh     = -1;
+  this->xine   = class->xine;
+
+  this->input_plugin.open              = enigma_plugin_open;
+  this->input_plugin.get_capabilities  = enigma_plugin_get_capabilities;
+  this->input_plugin.read              = enigma_plugin_read;
+  this->input_plugin.read_block        = enigma_plugin_read_block;
+  this->input_plugin.seek              = enigma_plugin_seek;
+  this->input_plugin.get_current_pos   = enigma_plugin_get_current_pos;
+  this->input_plugin.get_length        = enigma_plugin_get_length;
+  this->input_plugin.get_blocksize     = enigma_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = enigma_plugin_get_mrl;
+  this->input_plugin.dispose           = enigma_plugin_dispose;
+  this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
+  this->input_plugin.input_class       = class_gen;
+
+  pthread_mutex_init(&this->find_sync_point_lock, 0);
+
+  this->metronom.input = this;
+
+  // xvdr
+  this->metronom.metronom.set_audio_rate             = set_audio_rate;
+  this->metronom.metronom.got_video_frame            = got_video_frame;
+  this->metronom.metronom.got_audio_samples          = got_audio_samples;
+  this->metronom.metronom.got_spu_packet             = got_spu_packet;
+  this->metronom.metronom.handle_audio_discontinuity = handle_audio_discontinuity;
+  this->metronom.metronom.handle_video_discontinuity = handle_video_discontinuity;
+  this->metronom.metronom.set_option                 = set_option;
+  this->metronom.metronom.get_option                 = get_option;
+  this->metronom.metronom.set_master                 = set_master;
+  this->metronom.metronom.exit                       = metronom_exit;
+
+  pthread_mutex_init(&this->metronom.mutex, NULL);
+
+  this->metronom.stream_metronom = stream->metronom;
+  stream->metronom = &this->metronom.metronom;
+
+  return &this->input_plugin;
+}
+
+void *init_class (xine_t *xine, void *data) {
+
+  enigma_input_class_t  *this;
+
+  this = calloc(1, sizeof (enigma_input_class_t));
+
+  this->xine   = xine;
+
+  this->input_class.get_instance       = enigma_class_get_instance;
+  this->input_class.identifier         = "ENIGMA";
+  this->input_class.description        = N_("ENIGMA2PC display device plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = default_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
+
+/*
+ * enigma input plugin class stuff
+ */
+static const char * const *enigma_class_get_autoplay_list(input_class_t *this_gen,
+                                          int *num_files)
+{
+  static const char * const mrls[] = {"enigma:/" ENIGMA_ABS_FIFO_DIR "/stream#demux:mpeg_pes", NULL};
+
+  (void)this_gen;
+  *num_files = 1;
+  return mrls;
+}
+
+void *enigma_input_init_plugin(xine_t *xine, const void *data)
+{
+  lprintf("init_class\n");
+  static const input_class_t this = {
+    .get_instance      = enigma_class_get_instance,
+    .identifier        = "ENIGMA",
+    .description       = N_("ENIGMA display device plugin"),
+    .get_dir           = NULL,
+    .get_autoplay_list = enigma_class_get_autoplay_list,
+    .dispose           = NULL,
+    .eject_media       = NULL
+  };
+  (void)xine;
+  (void)data;
+  return (input_class_t *)&this;
+}
diff -ruN o/src/enigma/Makefile.am pc/src/enigma/Makefile.am
--- o/src/enigma/Makefile.am	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/Makefile.am	2023-09-16 16:10:03.759636871 +0300
@@ -0,0 +1,13 @@
+include $(top_builddir)/misc/Makefile.plugins
+include $(top_srcdir)/misc/Makefile.common
+
+AM_CFLAGS  = $(DEFAULT_OCFLAGS) $(VISIBILITY_FLAG)
+AM_LDFLAGS = $(xineplug_ldflags)
+
+if ENABLE_ENIGMA
+xineplug_LTLIBRARIES = xineplug_enigma.la
+endif
+
+xineplug_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c post_enigma_video.c post_enigma_audio.c
+xineplug_enigma_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
+xineplug_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
diff -ruN o/src/enigma/post_enigma_audio.c pc/src/enigma/post_enigma_audio.c
--- o/src/enigma/post_enigma_audio.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/post_enigma_audio.c	2023-09-16 16:10:03.759636871 +0300
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2000-2018 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * select audio channel plugin for VDR
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define LOG_MODULE "enigma_audio"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_audio_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  uint8_t audio_channels;
+  int num_channels;
+
+}
+enigma_audio_post_plugin_t;
+
+
+static void enigma_audio_select_audio(enigma_audio_post_plugin_t *this, uint8_t channels)
+{
+  this->audio_channels = channels;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_audio_dispose(post_plugin_t *this_gen);
+
+/* replaced ao_port functions */
+static int            enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                                          uint32_t bits, uint32_t rate, int mode);
+static void           enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream);
+
+
+
+void *enigma_audio_init_plugin(xine_t *xine, const void *data)
+{
+  post_class_t *class = calloc(1, sizeof (post_class_t));
+
+  (void)xine;
+  (void)data;
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_audio_open_plugin;
+  class->identifier      = "enigma_audio";
+  class->description     = N_("modifies every audio frame as requested by ENIGMA2PC");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_audio_open_plugin(post_class_t *class_gen, int inputs,
+				      xine_audio_port_t **audio_target,
+				      xine_video_port_t **video_target)
+{
+  enigma_audio_post_plugin_t *this = calloc(1, sizeof (enigma_audio_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_audio_port_t       *port;
+
+  if (!this || !audio_target || !audio_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  (void)class_gen;
+  (void)inputs;
+  (void)video_target;
+
+  _x_post_init(&this->post_plugin, 1, 0);
+  this->post_plugin.dispose = enigma_audio_dispose;
+
+  port = _x_post_intercept_audio_port(&this->post_plugin, audio_target[ 0 ], &input, &output);
+  port->new_port.open       = enigma_audio_port_open;
+  port->new_port.put_buffer = enigma_audio_port_put_buffer;
+
+  this->post_plugin.xine_post.audio_input[ 0 ] = &port->new_port;
+
+
+
+  this->audio_channels = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_audio_dispose(post_plugin_t *this_gen)
+{
+
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+      xine_event_dispose_queue(this->event_queue);
+
+    free(this_gen);
+  }
+}
+
+static int enigma_audio_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                               uint32_t bits, uint32_t rate, int mode) {
+
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+
+  _x_post_rewire(&this->post_plugin);
+  _x_post_inc_usage(port);
+
+  port->stream = stream;
+  port->bits = bits;
+  port->rate = rate;
+  port->mode = mode;
+
+  this->num_channels = _x_ao_mode2channels(mode);
+
+  return (port->original_port->open) (port->original_port, stream, bits, rate, mode );
+}
+
+
+static void enigma_audio_port_put_buffer(xine_audio_port_t *port_gen, audio_buffer_t *buf, xine_stream_t *stream)
+{
+  post_audio_port_t       *port = (post_audio_port_t *)port_gen;
+  enigma_audio_post_plugin_t *this = (enigma_audio_post_plugin_t *)port->post;
+  xine_event_t *event;
+
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->audio_channels = 0;
+  }
+
+  if (!this->enigma_stream)
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_ENIGMA_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 1; /* enigma_audio */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_ENIGMA_SELECTAUDIO)
+      {
+        enigma_select_audio_data_t *data = (enigma_select_audio_data_t *)event->data;
+
+        enigma_audio_select_audio(this, data->channels);
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  if (this->num_channels == 2
+      && this->audio_channels != 0
+      && this->audio_channels != 3)
+  {
+    audio_buffer_t *enigma_buf = port->original_port->get_buffer(port->original_port);
+    enigma_buf->num_frames = buf->num_frames;
+    enigma_buf->vpts = buf->vpts;
+    enigma_buf->frame_header_count = buf->frame_header_count;
+    enigma_buf->first_access_unit = buf->first_access_unit;
+    /* FIXME: The audio buffer should contain this info.
+     *        We should not have to get it from the open call.
+     */
+    enigma_buf->format.bits = buf->format.bits;
+    enigma_buf->format.rate = buf->format.rate;
+    enigma_buf->format.mode = buf->format.mode;
+    _x_extra_info_merge(enigma_buf->extra_info, buf->extra_info);
+
+    {
+      int step = buf->format.bits / 8;
+      uint8_t *src = (uint8_t *)buf->mem;
+      uint8_t *dst = (uint8_t *)enigma_buf->mem;
+
+      if (this->audio_channels == 2)
+        src += step;
+
+      int i, k;
+      for (i = 0; i < buf->num_frames; i++)
+      {
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src -= step;
+
+        for (k = 0; k < step; k++)
+          *dst++ = *src++;
+
+        src += step;
+      }
+    }
+
+    /* pass data to original port */
+    port->original_port->put_buffer(port->original_port, enigma_buf, stream);
+
+    /* free data from origial buffer */
+    buf->num_frames = 0; /* UNDOCUMENTED, but hey, it works! Force old audio_out buffer free. */
+  }
+
+  port->original_port->put_buffer(port->original_port, buf, stream);
+
+  return;
+}
diff -ruN o/src/enigma/post_enigma_video.c pc/src/enigma/post_enigma_video.c
--- o/src/enigma/post_enigma_video.c	1970-01-01 03:00:00.000000000 +0300
+++ pc/src/enigma/post_enigma_video.c	2023-09-16 16:10:03.760636818 +0300
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2000-2018 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * frame scaler plugin for ENIGMA2PC
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define LOG_MODULE "enigma_video"
+/*
+#define LOG
+#define LOG_VERBOSE
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_video_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  int8_t trick_speed_mode;
+  int8_t enabled;
+
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+  int32_t old_frame_left;
+  int32_t old_frame_top;
+  int32_t old_frame_width;
+  int32_t old_frame_height;
+  double  old_frame_ratio;
+
+}
+enigma_video_post_plugin_t;
+
+
+static void enigma_video_set_video_window(enigma_video_post_plugin_t *this, int32_t x, int32_t y, int32_t w, int32_t h, int32_t w_ref, int32_t h_ref)
+{
+  this->enabled = 0;
+
+  this->x     = x;
+  this->y     = y;
+  this->w     = w;
+  this->h     = h;
+  this->w_ref = w_ref;
+  this->h_ref = h_ref;
+
+  if (w != w_ref || h != h_ref)
+    this->enabled = 1;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_video_dispose(post_plugin_t *this_gen);
+
+/* route preprocessing functions check */
+static int            enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame);
+
+/* replaced vo_frame functions */
+static int            enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream);
+
+
+void *enigma_video_init_plugin(xine_t *xine, const void *data)
+{
+  post_class_t *class = calloc(1, sizeof (post_class_t));
+
+  (void)xine;
+  (void)data;
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_video_open_plugin;
+  class->identifier      = "enigma";
+  class->description     = N_("modifies every video frame as requested by ENIGMA");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target)
+{
+  enigma_video_post_plugin_t *this = calloc(1, sizeof (enigma_video_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_video_port_t       *port;
+
+  if (!this || !video_target || !video_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  (void)class_gen;
+  (void)inputs;
+  (void)audio_target;
+
+  _x_post_init(&this->post_plugin, 0, 1);
+  this->post_plugin.dispose = enigma_video_dispose;
+
+  port = _x_post_intercept_video_port(&this->post_plugin, video_target[ 0 ], &input, &output);
+  port->route_preprocessing_procs = enigma_video_route_preprocessing_procs;
+  port->new_frame->draw           = enigma_video_draw;
+  this->post_plugin.xine_post.video_input[ 0 ] = &port->new_port;
+
+  this->enabled          = 0;
+  this->enigma_stream    = 0;
+  this->event_queue      = 0;
+  this->old_frame_left   = 0;
+  this->old_frame_top    = 0;
+  this->old_frame_width  = 0;
+  this->old_frame_height = 0;
+  this->old_frame_ratio  = 0;
+  this->trick_speed_mode = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_video_dispose(post_plugin_t *this_gen)
+{
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = 0;
+      event_data.y = 0;
+      event_data.w = 0;
+      event_data.h = 0;
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      xine_event_dispose_queue(this->event_queue);
+    }
+
+    free(this_gen);
+  }
+}
+
+static int enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  return !this->enabled
+    || (frame->format != XINE_IMGFMT_YUY2
+      && frame->format != XINE_IMGFMT_YV12);
+}
+
+
+static inline void enigma_video_scale(uint8_t *src, uint8_t *dst, int y_inc, int x_inc, int w_dst, int h_dst, int x, int y, int w, int h, int w_ref, int h_ref, int init)
+{
+  int x0 = x * w_dst / w_ref;
+  int y0 = y * h_dst / h_ref;
+
+  int x1 = ((x + w) * w_dst - 1 + w_ref) / w_ref;
+  int y1 = ((y + h) * h_dst - 1 + h_ref) / h_ref;
+
+  int dx = x1 - x0;
+  int dy = y1 - y0;
+
+  int yy, xx;
+
+  int dy2    = dy + dy;
+  int h_dst2 = h_dst + h_dst;
+  int y_eps  = h_dst - dy2;
+
+  int dx2    = dx + dx;
+  int w_dst2 = w_dst + w_dst;
+  int x_eps0 = w_dst - dx2;
+
+  for (yy = 0; yy < y0; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+
+  for (yy = y0; yy < y1; yy++)
+  {
+    uint8_t *dst0 = dst;
+    uint8_t *src0 = src;
+
+    int x_eps = x_eps0;
+
+    for (xx = 0; xx < x0; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    for (xx = x0; xx < x1; xx++)
+    {
+      *dst0 = *src0;
+      dst0 += x_inc;
+
+      x_eps += w_dst2;
+      while (x_eps >= 0)
+      {
+        src0  += x_inc;
+        x_eps -= dx2;
+      }
+    }
+
+    for (xx = x1; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+
+    y_eps += h_dst2;
+    while (y_eps >= 0)
+    {
+      src   += y_inc;
+      y_eps -= dy2;
+    }
+  }
+
+  for (yy = y1; yy < h_dst; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+}
+
+static void enigma_video_scale_YUY2(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] * dst->crop_top + 2 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 2,  w         , h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 1 ] + offset, &dst->base[ 0 ][ 1 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 3 ] + offset, &dst->base[ 0 ][ 3 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+static void enigma_video_scale_YV12(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] *   dst->crop_top           + 1 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 1,  w         ,  h         , this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 1 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 1 ][ 0 ] + offset, &dst->base[ 1 ][ 0 ] + offset, dst->pitches[ 1 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 2 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 2 ][ 0 ] + offset, &dst->base[ 2 ][ 0 ] + offset, dst->pitches[ 2 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+
+static int enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t       *port = (post_video_port_t *)frame->port;
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  vo_frame_t *enigma_frame;
+  xine_event_t *event;
+  int skip;
+
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->old_frame_left   = 0;
+    this->old_frame_top    = 0;
+    this->old_frame_width  = 0;
+    this->old_frame_height = 0;
+    this->old_frame_ratio  = 0;
+  }
+
+  if (!this->enigma_stream)
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_ENIGMA_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 0; /* enigma_video */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_VDR_SETVIDEOWINDOW)
+      {
+        enigma_set_video_window_data_t *data = (enigma_set_video_window_data_t *)event->data;
+
+        enigma_video_set_video_window(this, data->x, data->y, data->w, data->h, data->w_ref, data->h_ref);
+      }
+      else if (event->type == XINE_EVENT_VDR_TRICKSPEEDMODE)
+      {
+/*
+        fprintf(stderr, "###############################: %p, %d\n", event->data, event->data_length);
+        this->trick_speed_mode = (0 != event->data_length);
+*/
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  {
+    int32_t frame_left   = frame->crop_left;
+    int32_t frame_width  = frame->width - frame->crop_left - frame->crop_right;
+    int32_t frame_top    = frame->crop_top;
+    int32_t frame_height = frame->height - frame->crop_top - frame->crop_bottom;
+    double  frame_ratio  = frame->ratio;
+
+    if (frame_left < 0)
+      frame_left = 0;
+    if (frame_width > frame->width)
+      frame_width = frame->width;
+    if (frame_top < 0)
+      frame_top = 0;
+    if (frame_height > frame->height)
+      frame_height = frame->height;
+
+    if (this->enigma_stream
+        && frame_width != 0
+        && frame_height != 0
+        && (this->old_frame_left    != frame_left
+          || this->old_frame_top    != frame_top
+          || this->old_frame_width  != frame_width
+          || this->old_frame_height != frame_height
+          || this->old_frame_ratio  != frame_ratio))
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = frame_left;
+      event_data.y = frame_top;
+      event_data.w = frame_width;
+      event_data.h = frame_height;
+      event_data.r = frame_ratio;
+
+      xprintf(this->enigma_stream->xine, XINE_VERBOSITY_LOG,
+            _(LOG_MODULE ": osd: (%d, %d)-(%d, %d)@%lg\n"), frame_left, frame_top, frame_width, frame_height, frame_ratio);
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      // Enigma2PC send event
+      xine_format_change_data_t event_data_enigma;
+
+      event_data_enigma.width = frame_width;
+      event_data_enigma.height = frame_height;
+
+      int ratio = (int)(10000 * frame_ratio + 0.5);
+      int matches4_3 = abs(ratio - 13333);
+      int matches16_9 = abs(ratio - 17778);
+      if (matches4_3 < matches16_9)
+       {
+        event_data_enigma.aspect = 2;
+       }
+      else
+      {
+        event_data_enigma.aspect = 3;
+      }
+      event_data_enigma.pan_scan = 0;
+
+      event.type        = XINE_EVENT_FRAME_FORMAT_CHANGE;
+      event.data        = &event_data_enigma;
+      event.data_length = sizeof (event_data_enigma);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      this->old_frame_left   = frame_left;
+      this->old_frame_top    = frame_top;
+      this->old_frame_width  = frame_width;
+      this->old_frame_height = frame_height;
+      this->old_frame_ratio  = frame_ratio;
+    }
+  }
+/*
+  fprintf(stderr, "~~~~~~~~~~~~ trickspeedmode: %d\n", this->trick_speed_mode);
+
+  if (this->vdr_stream
+      && this->trick_speed_mode)
+  {
+    frame->pts = 0;
+    frame->next->pts = 0;
+  }
+*/
+#if defined(LOG) && defined(LOG_VERBOSE)
+  {
+    int a = 0, b = 0, c = 0, d = 0;
+    if (stream)
+      _x_query_buffer_usage(stream, &a, &b, &c, &d);
+    lprintf("buffer usage: %3d, %2d, %2d, %2d, %p\n", a, b, c, d, stream);
+  }
+#endif
+
+  if (!this->enabled
+      || frame->bad_frame
+      || (frame->format != XINE_IMGFMT_YUY2
+          && frame->format != XINE_IMGFMT_YV12)
+      || frame->proc_frame
+      || frame->proc_slice)
+  {
+    _x_post_frame_copy_down(frame, frame->next);
+    skip = frame->next->draw(frame->next, stream);
+    _x_post_frame_copy_up(frame, frame->next);
+    return skip;
+  }
+
+  enigma_frame = port->original_port->get_frame(port->original_port,
+    frame->width, frame->height, frame->ratio, frame->format, frame->flags | VO_BOTH_FIELDS);
+
+  _x_post_frame_copy_down(frame, enigma_frame);
+
+  switch (enigma_frame->format)
+  {
+  case XINE_IMGFMT_YUY2:
+    enigma_video_scale_YUY2(this, frame, enigma_frame);
+    break;
+
+  case XINE_IMGFMT_YV12:
+    enigma_video_scale_YV12(this, frame, enigma_frame);
+    break;
+  }
+
+  skip = enigma_frame->draw(enigma_frame, stream);
+  _x_post_frame_copy_up(frame, enigma_frame);
+  enigma_frame->free(enigma_frame);
+
+  return skip;
+}
diff -ruN o/src/Makefile.am pc/src/Makefile.am
--- o/src/Makefile.am	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/Makefile.am	2023-09-16 16:10:03.760636818 +0300
@@ -16,4 +16,5 @@
 	libreal \
 	post \
 	combined \
-	vdr
+	vdr \
+	enigma
diff -ruN o/src/Makefile.in pc/src/Makefile.in
--- o/src/Makefile.in	2018-01-11 15:51:10.000000000 +0300
+++ pc/src/Makefile.in	2023-09-16 16:10:03.760636818 +0300
@@ -567,7 +567,8 @@
 	libreal \
 	post \
 	combined \
-	vdr
+	vdr \
+	enigma
 
 all: all-recursive
 
diff -ruN o/src/video_out/video_out_opengl.c pc/src/video_out/video_out_opengl.c
--- o/src/video_out/video_out_opengl.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/video_out/video_out_opengl.c	2023-09-16 16:10:03.761636765 +0300
@@ -135,6 +135,14 @@
 #define MY_PI                3.1415926
 #define MY_2PI               6.2831853
 
+typedef struct opengl_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} opengl_argb_layer_t;
 
 typedef struct {
   vo_frame_t         vo_frame;
@@ -212,8 +220,14 @@
 
   /* Frame state */
   opengl_frame_t    *frame[NUM_FRAMES_BACKLOG];
+
+  /* Overlay */
   x11osd            *xoverlay;
+  opengl_argb_layer_t argb_layer;
   int                ovl_changed;
+  int                last_ovl_width, last_ovl_height;
+  int                tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   config_values_t   *config;
   xine_t            *xine;
@@ -243,6 +257,10 @@
     enum render_e defaction;
     /* Fallback: change to following render backend if this one doesn't work */
     int fallback;
+    /* Upload new overlay image; Returns 0 if failed */
+    int (*ovl_image)(opengl_driver_t *, opengl_frame_t *);
+    /* Display current overlay */
+    void (*ovl_display)(opengl_driver_t *, opengl_frame_t *);
 } opengl_render_t;
 
 
@@ -272,10 +290,21 @@
   float           tx, ty;
 
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
+
   tx = (float) frame->width  / this->tex_width;
   ty = (float) frame->height / this->tex_height;
   /* Draw quad */
@@ -287,6 +316,56 @@
   glEnd ();
 }
 
+/* Static Overlay display */
+static void render_overlay (opengl_driver_t *this, opengl_frame_t *frame) {
+  int             x1, x2, y1, y2;
+  float           tx, ty;
+
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  
+  if (this->tex_ovl_width == 0 && this->tex_ovl_height == 0) // Image_Pipeline renderer is active (no texture support)
+  {
+    glPixelZoom   (((float)this->gui_width)    / this->argb_layer.width,
+		- ((float)this->gui_height)   / this->argb_layer.height);
+    glRasterPos2i (0, 0);
+    glDrawPixels  (this->argb_layer.width, this->argb_layer.height, GL_BGRA,
+			GL_UNSIGNED_BYTE, this->argb_layer.buffer);
+  }
+  else
+  {
+    if (this->glBindTextureEXT) // bind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+
+    if (this->fprog != -1)  // 2D_Tex_Fragprog is active which uses a pixelshader to make yuv2rgb conversion
+                            // -> disable it because texture is already argb
+      glDisable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    /* Calc texture/rectangle coords */
+    x1 = 0;
+    y1 = 0;
+    x2 = this->gui_width;
+    y2 = this->gui_height;
+    tx = (float) this->argb_layer.width  / this->tex_ovl_width;
+    ty = (float) this->argb_layer.height / this->tex_ovl_height;
+
+    /* Draw quad */
+    glBegin (GL_QUADS);
+    glTexCoord2f (tx, ty);   glVertex2i (x2, y2);
+    glTexCoord2f (0,  ty);   glVertex2i (x1, y2);
+    glTexCoord2f (0,  0);    glVertex2i (x1, y1);
+    glTexCoord2f (tx, 0);    glVertex2i (x2, y1);
+    glEnd ();
+
+    if (this->fprog != -1)  // enable pixelshader for next normal video frame
+      glEnable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    if (this->glBindTextureEXT) // unbind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 0);
+  }
+  glDisable(GL_BLEND);
+}
+
 /* Static 2d texture tiled based display */
 static void render_tex2dtiled (opengl_driver_t *this, opengl_frame_t *frame) {
   int    tex_w, tex_h, frame_w, frame_h;
@@ -298,10 +377,20 @@
   frame_w = frame->width;
   frame_h = frame->height;
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
   txa = 1.0 / tex_w;
   tya = 1.0 / tex_h;
   txb = (float) frame_w / (tex_w-2);	/* temporary: total */
@@ -332,11 +421,23 @@
 
 /* Static image pipline based display */
 static void render_draw (opengl_driver_t *this, opengl_frame_t *frame) {
-  glPixelZoom   (((float)this->sc.output_width)    / frame->width,
-		 - ((float)this->sc.output_height) / frame->height);
-  glRasterPos2i (this->sc.output_xoffset, this->sc.output_yoffset);
-  glDrawPixels  (frame->width, frame->height, RGB_TEXTURE_FORMAT,
-		 GL_UNSIGNED_BYTE, frame->rgb);
+	
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    glPixelZoom(((float)this->video_window_width)  / frame->width,
+              - ((float)this->video_window_height) / frame->height);
+    glRasterPos2i(this->video_window_x, this->video_window_y);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
+  else
+  {
+    glPixelZoom(((float)this->sc.output_width)  / frame->width,
+              - ((float)this->sc.output_height) / frame->height);
+    glRasterPos2i(this->sc.output_xoffset, this->sc.output_yoffset);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
 }
 
 /* Animated spinning cylinder */
@@ -487,6 +588,45 @@
   return 2;
 }
 
+/* holds/allocates extra texture for overlay */
+/* returns 0: allocation failure  1: texture updated  2: texture kept */
+static int render_help_overlay_image_tex(opengl_driver_t *this, int new_w, int new_h,
+				GLint glformat, GLint texformat) {
+  int tex_w, tex_h, err;
+
+  /* check necessary texture size and allocate */
+  if (new_w != this->last_ovl_width ||
+      new_h != this->last_ovl_height ||
+      ! this->tex_ovl_width || ! this->tex_ovl_height) {
+    tex_w = tex_h = 16;
+    while (tex_w < new_w)
+      tex_w <<= 1;
+    while (tex_h < new_h)
+      tex_h <<= 1;
+
+    if (tex_w != this->tex_ovl_width || tex_h != this->tex_ovl_height) {
+      char *tmp = calloc (tex_w * tex_h, 4); /* 4 enough until RGBA */
+      if (this->glBindTextureEXT)  // xine code binds without call glGenTextures -> seems to me not correct
+        this->glBindTextureEXT (GL_TEXTURE_2D, 1000);  // bind 1000 to avoid collision with tiledtex textures / don't want to rewrite everything ...
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexImage2D (GL_TEXTURE_2D, 0, glformat, tex_w, tex_h,
+			0, texformat, GL_UNSIGNED_BYTE, tmp);
+      err = glGetError ();
+      free (tmp);
+      if (err)
+		return 0;
+      this->tex_ovl_width  = tex_w;
+      this->tex_ovl_height = tex_h;
+      lprintf ("* new texsize: %dx%d\n", tex_w, tex_h);
+    }
+    this->last_ovl_width  = new_w;
+    this->last_ovl_height = new_h;
+    return 1;
+  }
+  return 2;
+}
+
 /* returns 0: allocation failure  1: textures updated  2: textures kept */
 static int render_help_image_tiledtex (opengl_driver_t *this,
 				       int new_w, int new_h,
@@ -571,6 +711,24 @@
   return 1;
 }
 
+static int render_overlay_image_tex (opengl_driver_t *this, opengl_frame_t *frame) {
+  int ret;
+
+  // use own texture
+  ret = render_help_overlay_image_tex (this, this->argb_layer.width, this->argb_layer.height,
+                                       4, GL_BGRA);
+
+  if (! ret)
+    return 0;
+
+  if (this->glBindTextureEXT)
+    this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+  glTexSubImage2D (GL_TEXTURE_2D, 0, 4, 0, this->argb_layer.width, this->argb_layer.height,
+                   GL_BGRA, GL_UNSIGNED_BYTE,
+                   this->argb_layer.buffer);
+  return 1;
+}
+
 static int render_image_tiledtex (opengl_driver_t *this, opengl_frame_t *frame) {
   int ret;
   int frame_w, frame_h, tex_w, tex_h, i, j, nx, ny;
@@ -1040,20 +1198,20 @@
 /*
  * List of render backends
  */
-/* name, display, image,  setup, needsrgb, defaction, fallback */
+/* name, display, image,  setup, needsrgb, defaction, fallback, ovl_image, ovl_display */
 static const opengl_render_t opengl_rb[] = {
     {   "2D_Tex_Fragprog",  render_tex2d, render_image_fp_yuv,
-	render_setup_fp_yuv, 0, RENDER_NONE, 1 },
+	render_setup_fp_yuv, 0, RENDER_NONE, 1, render_overlay_image_tex, render_overlay },
     {   "2D_Tex",           render_tex2d, render_image_tex,
-	render_setup_tex2d,  1, RENDER_NONE, 2 },
+	render_setup_tex2d,  1, RENDER_NONE, 2, render_overlay_image_tex, render_overlay },
     {   "2D_Tex_Tiled",     render_tex2dtiled, render_image_tiledtex,
-	render_setup_tex2d,  1, RENDER_NONE, 3 },
+	render_setup_tex2d,  1, RENDER_NONE, 3, render_overlay_image_tex, render_overlay },
     {   "Image_Pipeline",   render_draw, render_image_nop,
-	render_setup_2d,     1, RENDER_NONE, -1 },
+	render_setup_2d,     1, RENDER_NONE, -1, render_image_nop, render_overlay },
     {   "Cylinder",         render_cyl, render_image_tex,
-	render_setup_cyl,    1, RENDER_DRAW, 1 },
+	render_setup_cyl,    1, RENDER_DRAW, 1, render_image_nop, render_image_nop },
     {   "Env_Mapped_Torus", render_env_tor, render_image_envtex,
-	render_setup_torus,  1, RENDER_DRAW, 1 }
+	render_setup_torus,  1, RENDER_DRAW, 1, render_image_nop, render_image_nop }
 } ;
 
 
@@ -1145,12 +1303,27 @@
 	CHECKERR ("pre-render");
 	ret = 1;
 	if (changed)
+	  if (this->argb_layer.changed) // clean window after every overlay change - do it twice because of double buffering
+	  {
+      glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+      if (this->argb_layer.changed == 1)
+        this->argb_layer.changed++;
+      else this->argb_layer.changed = 0;
+    }
 	  ret = (render->image) (this, frame);
-	(render->display) (this, frame);
-	if (this->render_double_buffer)
-	  glXSwapBuffers(this->display, this->drawable);
-	else
-	  glFlush ();
+    (render->display) (this, frame);
+    // display overlay
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+    {
+      ret = (render->ovl_image) (this, frame);
+      (render->ovl_display) (this, frame);
+    }
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    if (this->render_double_buffer)
+      glXSwapBuffers(this->display, this->drawable);
+    else
+      glFlush ();
 	/* Note: no glFinish() - work concurrently to the graphics pipe */
 	CHECKERR ("post-render");
 	XUnlockDisplay (this->display);
@@ -1214,6 +1387,7 @@
 	}
 	XUnlockDisplay (this->display);
 	this->tex_width = this->tex_height = 0;
+	this->tex_ovl_width = this->tex_ovl_height = 0;
       }
       break;
 
@@ -1587,6 +1761,9 @@
   opengl_driver_t  *this  = (opengl_driver_t *) this_gen;
   opengl_frame_t   *frame = (opengl_frame_t *) frame_gen;
 
+  if (overlay->width <= 0 || overlay->height <= 0 || (!overlay->rle && (!overlay->argb_layer || !overlay->argb_layer->buffer)))
+    return;
+
   /* Alpha Blend here */
   if (overlay->rle) {
     if (overlay->unscaled) {
@@ -1628,6 +1805,28 @@
 #     endif
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  { 
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(opengl_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy(this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static int opengl_redraw_needed (vo_driver_t *this_gen) {
@@ -1940,6 +2139,11 @@
     XFree(this->vinfo);
   }
 
+  pthread_mutex_lock (&this->argb_layer.mutex);
+  if (this->argb_layer.buffer)
+	free(this->argb_layer.buffer);
+  pthread_mutex_unlock (&this->argb_layer.mutex);
+
   _x_alphablend_free(&this->alphablend_extra_data);
 
   free (this);
@@ -2003,7 +2207,17 @@
   this->fprog = -1;
 
   this->xoverlay                = NULL;
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
   this->ovl_changed             = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
+  
   this->xine                    = class->xine;
   this->config                  = config;
 
diff -ruN o/src/video_out/video_out_vaapi.c pc/src/video_out/video_out_vaapi.c
--- o/src/video_out/video_out_vaapi.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/video_out/video_out_vaapi.c	2023-09-29 14:14:26.915712386 +0300
@@ -179,6 +179,15 @@
 
 } va_property_t;
 
+typedef struct vaapi_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} vaapi_argb_layer_t;
+
 struct vaapi_driver_s {
 
   vo_driver_t        vo_driver;
@@ -205,6 +214,13 @@
 
   uint32_t            vdr_osd_width;
   uint32_t            vdr_osd_height;
+  uint32_t            enigma_osd_width;
+  uint32_t            enigma_osd_height;
+
+  vaapi_argb_layer_t  argb_layer;
+  int                 last_ovl_width, last_ovl_height;
+  int                 tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                 video_window_width, video_window_height, video_window_x, video_window_y;
 
   uint32_t            overlay_output_width;
   uint32_t            overlay_output_height;
@@ -2461,16 +2477,32 @@
 
     if(format == XINE_IMGFMT_VAAPI) {
       lprintf("vaapi_ovl_associate hw\n");
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
+      vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
+                              va_context->va_surface_ids, RENDER_SURFACES,
+                              0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
+                              0, 0, this->overlay_bitmap_width, this->overlay_bitmap_height, VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD);
+      } else {
       vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
                               va_context->va_surface_ids, RENDER_SURFACES,
                               0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
                               0, 0, output_width, output_height, flags);
+             }
     } else {
       lprintf("vaapi_ovl_associate sw\n");
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
+          vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
+                              this->va_soft_surface_ids, SOFT_SURFACES,
+                              0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
+                              0, 0, this->overlay_bitmap_width, this->overlay_bitmap_height, VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD);
+      } else {
       vaStatus = vaAssociateSubpicture(va_context->va_display, this->va_subpic_id,
                               this->va_soft_surface_ids, SOFT_SURFACES,
                               0, 0, this->va_subpic_image.width, this->va_subpic_image.height,
                               0, 0, this->va_soft_images[0].width, this->va_soft_images[0].height, flags);
+             }
     }
 
     if(vaapi_check_status(this_gen, vaStatus, "vaAssociateSubpicture()")) {
@@ -2494,7 +2526,7 @@
 
   /* Apply OSD layer. */
   if(va_context->valid_context) {
-    lprintf("vaapi_overlay_begin chaned %d\n", changed);
+    lprintf("vaapi_overlay_begin changed %d\n", changed);
 
     pthread_mutex_lock(&this->vaapi_lock);
     DO_LOCKDISPLAY;
@@ -2527,13 +2559,42 @@
             (overlay->rgb_clut > 0 || overlay->hili_rgb_clut > 0) ? " rgb ": " ycbcr ",
             overlay->width, overlay->height, overlay->x, overlay->y,
             overlay->hili_left, overlay->hili_top,
-            overlay->hili_right, overlay->hili_bottom);
+            overlay->hili_right, overlay->hili_bottom,
+            overlay->video_window_width,overlay->video_window_height,
+            overlay->video_window_x,overlay->video_window_y);
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  {
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(vaapi_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy (this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
+
   if (overlay->argb_layer && overlay->argb_layer->buffer)
     lprintf("overlay[%d] argb %s %dx%d@%d,%d dirty rect %d,%d-%d,%d\n", i,
             overlay->unscaled ? " unscaled ": " scaled ",
             overlay->width, overlay->height, overlay->x, overlay->y,
             overlay->argb_layer->x1, overlay->argb_layer->y1,
-            overlay->argb_layer->x2, overlay->argb_layer->y2);
+            overlay->argb_layer->x2, overlay->argb_layer->y2,
+            overlay->extent_width, overlay->extent_height,
+            overlay->video_window_width,overlay->video_window_height,
+            overlay->video_window_x,overlay->video_window_y);
 
 
   this->overlays[i] = overlay;
@@ -2568,8 +2629,10 @@
   uint32_t output_width = frame->width;
   uint32_t output_height = frame->height;
   uint32_t unscaled_width = 0, unscaled_height = 0;
-  vo_overlay_t *first_scaled = NULL, *first_unscaled = NULL;
-  vaapi_rect_t dirty_rect, unscaled_dirty_rect;
+  uint32_t static_width = 0, static_height = 0;
+  vo_overlay_t *first_scaled = NULL, *first_unscaled = NULL, *static_scaled = NULL;
+  /* calm down compiler */
+  vaapi_rect_t dirty_rect, unscaled_dirty_rect, static_rect = {0, 0, 0, 0};
   int has_rle = 0;
 
   int i;
@@ -2664,6 +2727,16 @@
       else
         this->overlay_bitmap_height = (unscaled_height > this->sc.gui_height) ? unscaled_height : this->sc.gui_height;
 
+      if(this->enigma_osd_width)
+        this->overlay_bitmap_width =  (this->enigma_osd_width >  this->sc.gui_width) ? this->enigma_osd_width : this->sc.gui_width;
+      else
+        this->overlay_bitmap_width =  (unscaled_width >  this->sc.gui_width) ? unscaled_width : this->sc.gui_width;
+
+      if(this->enigma_osd_height)
+        this->overlay_bitmap_height = (this->enigma_osd_height > this->sc.gui_height) ? this->enigma_osd_height : this->sc.gui_height;
+      else
+        this->overlay_bitmap_height = (unscaled_height > this->sc.gui_height) ? unscaled_height : this->sc.gui_height;
+
     } else if (need_init) {
 
       if(this->vdr_osd_width) 
@@ -2676,6 +2749,16 @@
       else
         this->overlay_bitmap_height = (output_height > this->sc.gui_height) ? output_height : this->sc.gui_height;
 
+      if(this->enigma_osd_width)
+        this->overlay_bitmap_width =  (this->enigma_osd_width >  this->sc.gui_width) ? this->enigma_osd_width : this->sc.gui_width;
+      else
+        this->overlay_bitmap_width =  (output_width >  this->sc.gui_width) ? output_width : this->sc.gui_width;
+
+      if(this->enigma_osd_height)
+        this->overlay_bitmap_height = (this->enigma_osd_height > this->sc.gui_height) ? this->enigma_osd_height : this->sc.gui_height;
+      else
+        this->overlay_bitmap_height = (output_height > this->sc.gui_height) ? output_height : this->sc.gui_height;
+
     }
   }
 
@@ -2741,7 +2824,7 @@
   }
 
   this->ovl_changed = 0;
-  this->has_overlay = (first_scaled != NULL) | (first_unscaled != NULL);
+  this->has_overlay = (first_scaled != NULL) | (first_unscaled != NULL) | (static_scaled != NULL);
 
   lprintf("this->has_overlay %d\n", this->has_overlay);
   /* Apply OSD layer. */
@@ -3356,9 +3439,16 @@
     return vaStatus;
 
   if (!this->is_bound) {
+    if(this->video_window_width && this->video_window_height) // video is displayed in a small window
+    {
+    vaStatus = vaPutImage(va_context->va_display, va_surface_id, va_image->image_id,
+                        0, 0, this->video_window_x, this->video_window_y,
+                        0, 0, this->video_window_width, this->video_window_height);
+    } else {
     vaStatus = vaPutImage(va_context->va_display, va_surface_id, va_image->image_id,
                         0, 0, va_image->width, va_image->height,
                         0, 0, va_image->width, va_image->height);
+    }
     if(!vaapi_check_status(va_context->driver, vaStatus, "vaPutImage()"))
       return vaStatus;
   }
@@ -3438,12 +3528,22 @@
 #endif
     {
 
+      if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+      {
       vaStatus = vaPutSurface(va_context->va_display, va_surface_id, this->window,
                    this->sc.displayed_xoffset, this->sc.displayed_yoffset,
                    this->sc.displayed_width, this->sc.displayed_height,
+                   this->video_window_x, this->video_window_y,
+                   this->video_window_width, this->video_window_height,
+                   NULL, 0, flags);
+      } else {
+        vaStatus = vaPutSurface(va_context->va_display, va_surface_id, this->window,
+                   this->sc.displayed_xoffset, this->sc.displayed_yoffset,
+                   this->sc.displayed_width, this->sc.displayed_height,
                    this->sc.output_xoffset, this->sc.output_yoffset,
                    this->sc.output_width, this->sc.output_height,
                    NULL, 0, flags);
+      }
       if(!vaapi_check_status(this_gen, vaStatus, "vaPutSurface()"))
         return vaStatus;
     }
@@ -3729,14 +3829,10 @@
       this->props[property].value = this->sc.output_yoffset;
       break;
     case VO_PROP_MAX_NUM_FRAMES:
-#if 0 /* WTF !!!! */
       if(!this->guarded_render)
         this->props[property].value = RENDER_SURFACES;
       else
         this->props[property].value = 2;
-#else
-      this->props[property].value = RENDER_SURFACES;
-#endif
       break;
   } 
 
@@ -3909,6 +4005,8 @@
   config->unregister_callback(config, "video.output.vaapi_swap_uv_planes");
   config->unregister_callback(config, "video.output.vaapi_vdr_osd_height");
   config->unregister_callback(config, "video.output.vaapi_vdr_osd_width");
+  config->unregister_callback(config, "video.output.vaapi_enigma_osd_height");
+  config->unregister_callback(config, "video.output.vaapi_enigma_osd_width");
 
   // vaapi_lock is locked at this point, either from vaapi_dispose or vaapi_open_plugin
 
@@ -3942,6 +4040,11 @@
   pthread_mutex_unlock(&this->vaapi_lock);
   pthread_mutex_destroy(&this->vaapi_lock);
 
+  pthread_mutex_lock (&this->argb_layer.mutex);
+  if (this->argb_layer.buffer)
+	free(this->argb_layer.buffer);
+  pthread_mutex_unlock (&this->argb_layer.mutex);
+
   cm_close (this);
 
   free (this);
@@ -3967,6 +4070,20 @@
   this->vdr_osd_height = entry->num_value;
 }
 
+static void vaapi_enigma_osd_width_flag( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
+
+  this->enigma_osd_width = entry->num_value;
+}
+
+static void vaapi_enigma_osd_height_flag( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
+
+  this->enigma_osd_height = entry->num_value;
+}
+
 static void vaapi_deinterlace_flag( void *this_gen, xine_cfg_entry_t *entry )
 {
   vaapi_driver_t  *this  = (vaapi_driver_t *) this_gen;
@@ -4041,6 +4158,16 @@
 
   pthread_mutex_init(&this->vaapi_lock, NULL);
   pthread_mutex_lock(&this->vaapi_lock);
+  
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
 
   this->config                  = config;
   this->xine                    = class->xine;
@@ -4178,6 +4305,9 @@
   this->deinterlace                    = 0;
   this->vdr_osd_width                  = 0;
   this->vdr_osd_height                 = 0;
+  this->enigma_osd_width               = 0;
+  this->enigma_osd_height              = 0;
+  this->tex_ovl_width                  = this->tex_ovl_height = 0;
 
   this->vdr_osd_width = config->register_num( config, "video.output.vaapi_vdr_osd_width", 0,
         _("vaapi: VDR osd width workaround."),
@@ -4189,6 +4319,16 @@
         _("vaapi: VDR osd height workaround."),
         10, vaapi_vdr_osd_height_flag, this );
 
+  this->enigma_osd_width = config->register_num( config, "video.output.vaapi_enigma_osd_width", 0,
+        _("vaapi: ENIGMA osd width workaround."),
+        _("vaapi: ENIGMA osd width workaround."),
+        10, vaapi_enigma_osd_width_flag, this );
+
+  this->enigma_osd_height = config->register_num( config, "video.output.vaapi_enigma_osd_height", 0,
+        _("vaapi: ENIGMA osd height workaround."),
+        _("vaapi: ENIGMA osd height workaround."),
+        10, vaapi_enigma_osd_height_flag, this );
+
   this->deinterlace = config->register_num( config, "video.output.vaapi_deinterlace", 0,
         _("vaapi: set deinterlace to 0 ( none ), 1 ( top field ), 2 ( bob )."),
         _("vaapi: set deinterlace to 0 ( none ), 1 ( top field ), 2 ( bob )."),
diff -ruN o/src/video_out/video_out_vdpau.c pc/src/video_out/video_out_vdpau.c
--- o/src/video_out/video_out_vdpau.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/video_out/video_out_vdpau.c	2023-09-16 16:10:03.762636713 +0300
@@ -744,7 +744,14 @@
       this->ovl_video_dest_rect = vid_rect;
     }
 
-    if (!ovl->unscaled) {
+    if (ovl->unscaled==2) {
+      ovl_rect.x0 = 0;
+      ovl_rect.y0 = 0;
+      ovl_rect.x1 = this->sc.gui_width;
+      ovl_rect.y1 = this->sc.gui_height;
+      this->ovl_changed = 1;
+    }
+    else if (ovl->unscaled==0) {
       double rx, ry;
 
       if (zoom) {
@@ -2187,6 +2194,12 @@
       this->deinterlace = value;
       vdpau_set_deinterlace( this_gen );
       break;
+    case VO_PROP_DEINTERLACE_SD:
+      this->deinterlace_method_sd = value;
+      break;
+    case VO_PROP_DEINTERLACE_HD:
+      this->deinterlace_method_hd = value;
+      break;
     case VO_PROP_ZOOM_X:
       if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
         this->zoom_x = value;
diff -ruN o/src/xine-engine/osd.c pc/src/xine-engine/osd.c
--- o/src/xine-engine/osd.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/xine-engine/osd.c	2023-09-16 16:10:03.762636713 +0300
@@ -509,6 +509,10 @@
   return _osd_show(osd, vpts, 1);
 }
 
+static int osd_show_gui_scaled (osd_object_t *osd, int64_t vpts) {
+  return _osd_show(osd, vpts, 2);
+}
+
 /*
  * send event to hide osd at given pts (0=now)
  * the object is not changed. there may be subsequent drawing  on it.
@@ -1913,6 +1917,7 @@
   this->draw_bitmap        = osd_draw_bitmap;
   this->set_argb_buffer    = osd_set_argb_buffer;
   this->show_unscaled      = osd_show_unscaled;
+  this->show_scaled        = osd_show_gui_scaled;
   this->get_capabilities   = osd_get_capabilities;
   this->set_extent         = osd_set_extent;
   this->set_video_window   = osd_set_video_window;
diff -ruN o/src/xine-engine/video_out.c pc/src/xine-engine/video_out.c
--- o/src/xine-engine/video_out.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/xine-engine/video_out.c	2023-09-16 16:10:03.763636660 +0300
@@ -190,6 +190,7 @@
 
   /* pts value when decoder delivered last video frame */
   int64_t                   last_delivery_pts;
+  int64_t                   last_pts;
 
   video_overlay_manager_t  *overlay_source;
 
@@ -198,6 +199,7 @@
   int                       current_width, current_height;
   int64_t                   current_duration;
 
+  int                       framerate;
   int                       frame_drop_limit_max;
   int                       frame_drop_limit;
   int                       frame_drop_cpt;
@@ -1339,6 +1341,23 @@
       }
     }
     img->stream = stream;
+    int new_framerate = img->duration==0?0:90000*1000/img->duration;
+    if (this->framerate != new_framerate) {
+      this->framerate = new_framerate;
+
+      xine_event_t event;
+      xine_framerate_data_t data;
+      event.type = XINE_EVENT_FRAMERATE_CHANGE;
+      event.stream = stream;
+      event.data = &data;
+      event.data_length = sizeof(data);
+      data.framerate = this->framerate;
+      xine_event_send( stream, &event );
+    }
+
+    if (img->pts!=0)
+      this->last_pts = img->pts;
+
     _x_extra_info_merge( img->extra_info, stream->video_decoder_extra_info );
     stream->metronom->got_video_frame (stream->metronom, img);
 #if 0
@@ -2166,6 +2185,7 @@
           img = duplicate_frame (this, this->last_frame);
           if (img) {
             img->vpts = vpts;
+            img->duration = DEFAULT_FRAME_DURATION;
             overlay_and_display_frame (this, img, vpts);
           }
         } else {
@@ -2449,6 +2469,10 @@
     pthread_mutex_unlock(&this->streams_lock);
     break;
 
+  case VO_PROP_LAST_PTS:
+    ret = (intptr_t)&this->last_pts;
+    break;
+
   /*
    * handle XINE_PARAM_xxx properties (convert from driver's range)
    */
diff -ruN o/src/xine-engine/xine_interface.c pc/src/xine-engine/xine_interface.c
--- o/src/xine-engine/xine_interface.c	2018-01-11 15:49:47.000000000 +0300
+++ pc/src/xine-engine/xine_interface.c	2023-09-16 16:10:03.763636660 +0300
@@ -841,6 +841,10 @@
   this->osd.renderer->show_unscaled(&this->osd, vpts);
 }
 
+void xine_osd_show_scaled(xine_osd_t *this, int64_t vpts) {
+  this->osd.renderer->show_scaled(&this->osd, vpts);
+}
+
 void xine_osd_hide(xine_osd_t *this, int64_t vpts) {
   this->osd.renderer->hide(&this->osd, vpts);
 }
